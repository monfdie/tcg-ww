<%- include('../partials/header') %>

<style>
    .page-container { padding: 0 !important; max-width: 100% !important; height: 100%; display: flex; flex-direction: column; }
    .player-header { height: auto !important; min-height: 70px; }
    .player-info-wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px; }
    .player-avatar { width: 54px; height: 54px; border-radius: 50%; object-fit: cover; box-shadow: 0 0 12px rgba(0,0,0,0.6); display: none; }
    
    /* --- СТИЛИ ДЛЯ DECK BUILDER (ПОСТ-ИГРА) --- */
    #deck-builder-layer {
        display: none; /* Скрыто до конца драфта */
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: radial-gradient(circle at center, #1a233a 0%, #0b0d17 100%);
        z-index: 100;
        flex-direction: column; align-items: center; justify-content: center;
    }

    .builder-container {
        display: flex; gap: 50px; width: 90%; max-width: 1200px; justify-content: center;
    }

    .builder-side {
        display: flex; flex-direction: column; gap: 20px; align-items: center;
        background: rgba(0,0,0,0.3); padding: 30px; border-radius: 10px; border: 1px solid #3c4566;
    }

    .deck-row {
        display: flex; gap: 15px; align-items: center;
    }

    .deck-slot {
        width: 70px; height: 70px; border-radius: 50%;
        border: 2px solid #555; background: rgba(0,0,0,0.5);
        display: flex; align-items: center; justify-content: center;
        cursor: pointer; transition: 0.2s; position: relative;
    }
    .deck-slot:hover { border-color: #fff; transform: scale(1.05); }
    .deck-slot img { width: 100%; height: 100%; border-radius: 50%; object-fit: cover; }
    
    /* Модалка выбора персонажа */
    #char-select-modal {
        display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); z-index: 200;
        align-items: center; justify-content: center;
    }
    .select-box {
        background: #161c30; border: 1px solid #4facfe; padding: 20px; border-radius: 8px;
        width: 600px; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;
    }
    .select-char-item {
        width: 80px; height: 80px; border-radius: 4px; cursor: pointer; border: 2px solid transparent;
        background: #000; position: relative;
    }
    .select-char-item:hover { border-color: #fff; }
    .select-char-item img { width: 100%; height: 100%; object-fit: cover; }
    
    .finish-btn {
        margin-top: 30px; padding: 15px 40px; font-size: 1.2em; font-weight: bold;
        background: #d4af37; color: #000; border: none; border-radius: 4px; cursor: pointer;
        font-family: 'Cinzel', serif; letter-spacing: 2px;
    }
    .finish-btn:hover { box-shadow: 0 0 20px rgba(212, 175, 55, 0.5); }
</style>

<div id="game-screen">
    <div class="game-header">
         <div id="room-container">
             <div id="room-display" onclick="copyRoomCode()">CODE: <%= roomId %></div>
             <span id="copy-toast">Code Copied!</span>
         </div>
         <div class="reserve-timer blue-res"><span id="blue-res">3:00</span></div>
         <div id="status">Waiting...</div>
         <div class="reserve-timer red-res"><span id="red-res">3:00</span></div>
    </div>

     <div class="draft-area">
         <div id="immunity-top-display" class="immunity-top-container" style="display: none;">
             <div class="im-label">IMMUNE</div>
             <div class="im-row" id="immunity-icons-row"></div>
         </div>
         <div class="team-side blue-side">
             <div class="player-header">
                 <div id="blue-timer" class="turn-timer">45</div>
                 <div class="player-info-wrapper">
                     <img id="blue-avatar" class="player-avatar" src="" alt="">
                     <h2 id="blue-name-display">PLAYER 1</h2>
                 </div>
                 <div id="blue-ready-switch" class="ready-switch" onclick="toggleReady('blue')">
                     <div class="switch-circle"></div>
                 </div>
             </div>
             <div class="ban-row" id="blue-bans"></div>
             <div class="pick-row" id="blue-picks-1"></div>
             <div class="pick-row-small" id="blue-picks-2"></div>
         </div>
         <div class="center-axis">
             <div class="mid-label ban-label">BANS</div>
             <div class="mid-label pick-label">PICKS</div>
         </div>
         <div class="team-side red-side">
             <div class="player-header">
                 <div id="red-ready-switch" class="ready-switch" onclick="toggleReady('red')">
                     <div class="switch-circle"></div>
                 </div>
                 <div class="player-info-wrapper">
                     <img id="red-avatar" class="player-avatar" src="" alt="">
                     <h2 id="red-name-display">PLAYER 2</h2>
                 </div>
                 <div id="red-timer" class="turn-timer">45</div>
             </div>
             <div class="ban-row" id="red-bans"></div>
             <div class="pick-row" id="red-picks-1"></div>
             <div class="pick-row-small" id="red-picks-2"></div>
         </div>
     </div>

     <div class="controls-area">
         <button id="skip-btn" class="round-btn" onclick="skipTurn()">SKIP</button>
         <button id="confirm-btn" class="confirm-btn round-btn" onclick="confirmSelection()" disabled>SELECT</button>
     </div>
     <div class="char-pool" id="char-pool-container"></div>
</div>

<div id="deck-builder-layer">
    <h1 style="color: #fff; font-family: 'Cinzel', serif; margin-bottom: 30px;">Assemble Your Decks</h1>
    
    <div class="builder-container">
        <div class="builder-side">
            <h2 id="bd-blue-name" style="color: #4facfe;">Player 1</h2>
            <div id="blue-deck-grid" style="display: flex; flex-direction: column; gap: 15px;"></div>
        </div>

        <div style="display: flex; align-items: center; color: #fff; font-size: 2em; font-family: 'Cinzel', serif;">VS</div>

        <div class="builder-side">
            <h2 id="bd-red-name" style="color: #ff6b6b;">Player 2</h2>
            <div id="red-deck-grid" style="display: flex; flex-direction: column; gap: 15px;"></div>
        </div>
    </div>

    <button class="finish-btn" onclick="finishMatch()">SAVE & FINISH</button>
</div>

<div id="char-select-modal" onclick="closeSelectModal(event)">
    <div class="select-box" id="select-box-content">
        </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script src="/draft-rules.js"></script>

<script>
    const socket = io({ transports: ['websocket'] });
    const currentRoom = '<%= roomId %>';
    const myUserId = sessionStorage.getItem('draft_user_id') || Math.random().toString(36).substring(2);
    sessionStorage.setItem('draft_user_id', myUserId);
    
    let myRole = '', currentDraftType = 'gitcg';
    let charsData = {}, selectedCharId = null, isGameStarted = false, activeTeam = 'blue';
    const myRealDiscordId = '<%= locals.user ? locals.user.discordId : "" %>';
    const myAvatarHash = '<%= locals.user ? locals.user.avatar : "" %>';
    const savedData = <%- JSON.stringify(locals.savedData || null) %>;
    const serverChars = <%- JSON.stringify(locals.chars || null) %>;

    // Переменные для Deck Builder
    let currentSlotIndex = null;
    let myPicksList = []; // Мои доступные чары

    // Инициализация (как раньше)
    if (savedData) {
        // ... (код просмотра реплея - оставляем как было, можно упростить для краткости)
        socket.disconnect(); charsData = serverChars;
        // Если это реплей, можно показать сразу DeckBuilder с заполненными деками, но пока оставим старый вид
        // или переделаем под новый стиль, если захотите.
        renderRows(); 
        const mockState = {
            gameStarted: true, currentTeam: 'none', currentAction: 'none',
            bans: savedData.bans, bluePicks: savedData.bluePicks, redPicks: savedData.redPicks,
            blueName: savedData.blueName, redName: savedData.redName,
            blueDiscordId: savedData.blueDiscordId, redDiscordId: savedData.redDiscordId,
            blueAvatar: savedData.blueAvatar, redAvatar: savedData.redAvatar,
            draftType: savedData.draftType, immunityPhaseActive: false,
            immunityPool: savedData.immunityPool||[], immunityBans: savedData.immunityBans||[],
            stepIndex: 999, ready: { blue: true, red: true },
            draftFinished: false // В реплее не показываем билдер
        };
        updateUI(mockState);
    } else {
        socket.on('connect', () => {
            if (currentRoom && myUserId) socket.emit('rejoin_game', { roomId: currentRoom, userId: myUserId, discordId: myRealDiscordId, avatar: myAvatarHash });
        });
        socket.on('init_game', (data) => {
            myRole = data.role; charsData = data.chars; currentDraftType = data.state.draftType || 'gitcg';
            document.getElementById('room-display').innerText = `CODE: ${currentRoom}` + (myRole === 'spectator' ? " (SPEC)" : "");
            renderRows(); updateUI(data.state);
        });
        socket.on('update_state', updateUI);
        socket.on('game_started', () => { isGameStarted = true; });
        socket.on('game_over', (state) => { updateUI(state); }); // Драфт кончился
        socket.on('timer_tick', (data) => {
            const t = typeof data === 'object' ? data.main : data;
            document.getElementById('blue-timer').innerText=t; document.getElementById('red-timer').innerText=t;
            if(typeof data === 'object') {
                 document.getElementById('blue-res').innerText = formatTime(data.blueReserve);
                 document.getElementById('red-res').innerText = formatTime(data.redReserve);
            }
        });
        socket.on('match_saved_success', () => {
            alert("Match Saved Successfully!");
            window.location.href = '/';
        });
    }

    function formatTime(s) { if (s < 0) s = 0; const m=Math.floor(s/60), sec=s%60; return `${m}:${sec<10?'0':''}${sec}`; }
    function toggleReady(r) { if(myRole===r) socket.emit('player_ready', currentRoom); }
    function copyRoomCode() { navigator.clipboard.writeText(currentRoom); }
    function skipTurn() { if(currentRoom && !savedData) socket.emit('skip_action', currentRoom); }
    
    // --- РЕНДЕР ПУЛА И СЛОТОВ (ОСТАВЛЯЕМ КАК БЫЛО) ---
    function renderRows() {
        const container = document.getElementById('char-pool-container'); container.innerHTML = '';
        const ladder = document.createElement('div'); ladder.className = 'ladder-container';
        const schema = DRAFT_RULES[currentDraftType];
        if(schema) {
            schema.forEach((step, i) => {
                const d = document.createElement('div');
                const sideClass = step.team === 'blue' ? 'step-left' : 'step-right';
                let colorClass = 'step-pick'; 
                if (step.type.includes('ban')) { colorClass = 'step-ban'; } else if (step.immunity) { colorClass = 'step-immunity'; }
                d.className = `ladder-step ${sideClass} ${colorClass}`;
                d.id = `step-node-${i}`; d.innerText = `${i+1}. ${step.type}`;
                ladder.appendChild(d);
            });
            container.appendChild(ladder);
        }
        ['cryo','hydro','pyro','electro','anemo','geo','dendro'].forEach(elem => {
            const row = document.createElement('div'); row.className = `element-row row-${elem}`;
            const chars = charsData[elem], mid = Math.ceil(chars.length/2);
            if(!chars) return; 
            const l = document.createElement('div'); l.className = 'row-half left-half';
            chars.slice(0,mid).forEach(c => l.appendChild(createChar(c)));
            const gap = document.createElement('div'); gap.className = 'row-gap';
            const r = document.createElement('div'); r.className = 'row-half right-half';
            chars.slice(mid).forEach(c => r.appendChild(createChar(c)));
            row.appendChild(l); row.appendChild(gap); row.appendChild(r);
            container.appendChild(row);
        });
    }

    function createChar(char) {
        const el = document.createElement('div'); el.className = 'char-option'; el.id = `char-${char.id}`;
        el.innerHTML = `<img src="${char.img}">`;
        el.onclick = () => {
            if(!isGameStarted || myRole === 'spectator' || savedData) return;
            document.querySelectorAll('.char-option').forEach(c => c.classList.remove('selected-pending'));
            selectedCharId = char.id; el.classList.add('selected-pending');
            document.getElementById('confirm-btn').disabled = false;
        };
        return el;
    }

    function confirmSelection() {
        if(selectedCharId && currentRoom && !savedData) {
            socket.emit('action', { roomId: currentRoom, charId: selectedCharId });
            selectedCharId = null; document.getElementById('confirm-btn').disabled = true;
            document.querySelectorAll('.char-option').forEach(c => c.classList.remove('selected-pending'));
        }
    }

    // --- ОБНОВЛЕНИЕ UI ---
    function updateUI(state) {
        // Если драфт закончился, включаем DECK BUILDER
        if (state.draftFinished) {
            document.getElementById('game-screen').style.display = 'none';
            document.getElementById('deck-builder-layer').style.display = 'flex';
            renderDeckBuilder(state);
            return;
        }

        // Обычная логика драфта
        isGameStarted = state.gameStarted; activeTeam = state.currentTeam;
        document.getElementById('blue-ready-switch').style.display = state.gameStarted?'none':'flex';
        document.getElementById('red-ready-switch').style.display = state.gameStarted?'none':'flex';
        if(!state.gameStarted) {
             state.ready.blue ? document.getElementById('blue-ready-switch').classList.add('ready-on') : document.getElementById('blue-ready-switch').classList.remove('ready-on');
             state.ready.red ? document.getElementById('red-ready-switch').classList.add('ready-on') : document.getElementById('red-ready-switch').classList.remove('ready-on');
        }
        document.getElementById('blue-name-display').innerText = state.blueName;
        document.getElementById('red-name-display').innerText = state.redName;
        // Аватарки
        const blueAv = document.getElementById('blue-avatar');
        if (state.blueAvatar && state.blueDiscordId) { blueAv.src = `https://cdn.discordapp.com/avatars/${state.blueDiscordId}/${state.blueAvatar}.png`; blueAv.style.display = 'block'; }
        const redAv = document.getElementById('red-avatar');
        if (state.redAvatar && state.redDiscordId) { redAv.src = `https://cdn.discordapp.com/avatars/${state.redDiscordId}/${state.redAvatar}.png`; redAv.style.display = 'block'; }
        
        let txt = "WAITING...";
        if(state.immunityPhaseActive) txt = `IMMUNITY: ${state.currentTeam} ${state.currentAction}`;
        else if(state.gameStarted) txt = `${state.currentTeam} IS ${state.currentAction==='ban'?'BANNING':'PICKING'}`;
        document.getElementById('status').innerText = txt.toUpperCase();

        updateImmunityTop(state);
        // Кнопка пропуска, рендер слотов, блокировка чаров (оставляем старый код для краткости)
        const skipBtn = document.getElementById('skip-btn');
        const isMyTurn = (myRole === state.currentTeam);
        if (state.immunityPhaseActive && isMyTurn && !savedData) {
             skipBtn.style.display = 'block';
             if (state.currentTeam === 'blue') skipBtn.classList.add('skip-left'); else skipBtn.classList.add('skip-right');
        } else skipBtn.style.display = 'none';

        renderSlots(state);
        // ... (остальной код disabled классов для чаров) ...
        document.querySelectorAll('.char-option').forEach(el => el.classList.remove('disabled', 'immunity-highlight'));
        state.bans.forEach(b => document.getElementById(`char-${b.id}`)?.classList.add('disabled'));
        [...state.bluePicks, ...state.redPicks].forEach(id => document.getElementById(`char-${id}`)?.classList.add('disabled'));
        // ... (здесь ваш код логики иммунитета) ...
    }

    // --- ФУНКЦИИ ДЛЯ DECK BUILDER ---
    let decksRendered = false;

    function renderDeckBuilder(state) {
        document.getElementById('bd-blue-name').innerText = state.blueName;
        document.getElementById('bd-red-name').innerText = state.redName;

        // Рендерим сетки только один раз (или перерисовываем данные)
        renderDeckGrid('blue-deck-grid', state.blueDecks, state.bluePicks, 'blue');
        renderDeckGrid('red-deck-grid', state.redDecks, state.redPicks, 'red');
        
        // Сохраняем наши пики для модалки
        if (myRole === 'blue') myPicksList = state.bluePicks;
        if (myRole === 'red') myPicksList = state.redPicks;
    }

    function renderDeckGrid(containerId, deckData, picks, team) {
        const container = document.getElementById(containerId);
        container.innerHTML = '';

        // 3 ряда (Deck 1, 2, 3)
        for (let i = 0; i < 3; i++) {
            const rowDiv = document.createElement('div');
            rowDiv.className = 'deck-row';
            
            // В каждом ряду 3 слота
            for (let j = 0; j < 3; j++) {
                const slotIndex = i * 3 + j;
                const charId = deckData[slotIndex];

                const slot = document.createElement('div');
                slot.className = 'deck-slot';
                
                if (charId) {
                    // Найти картинку
                    let allFlat = []; Object.values(charsData).forEach(arr => allFlat.push(...arr));
                    const char = allFlat.find(c => c.id === charId);
                    if (char) slot.innerHTML = `<img src="${char.img}">`;
                }

                // Клик только если это моя команда
                if (myRole === team) {
                    slot.onclick = () => openCharSelector(slotIndex);
                }

                rowDiv.appendChild(slot);
            }
            container.appendChild(rowDiv);
        }
    }

    function openCharSelector(slotIdx) {
        currentSlotIndex = slotIdx;
        const box = document.getElementById('select-box-content');
        box.innerHTML = '';
        
        let allFlat = []; Object.values(charsData).forEach(arr => allFlat.push(...arr));

        // Фильтруем: показываем только тех, кого я пикнул
        const myChars = allFlat.filter(c => myPicksList.includes(c.id));

        // Добавляем опцию "Пусто" (чтобы очистить слот)
        const emptyOption = document.createElement('div');
        emptyOption.className = 'select-char-item';
        emptyOption.style.border = '1px dashed #555';
        emptyOption.innerHTML = '<span style="color:#aaa; position:absolute; top:30%; left:25%;">CLEAR</span>';
        emptyOption.onclick = () => selectDeckChar(null);
        box.appendChild(emptyOption);

        myChars.forEach(char => {
            const div = document.createElement('div');
            div.className = 'select-char-item';
            div.innerHTML = `<img src="${char.img}">`;
            div.onclick = () => selectDeckChar(char.id);
            box.appendChild(div);
        });

        document.getElementById('char-select-modal').style.display = 'flex';
    }

    function closeSelectModal(e) {
        if (e.target.id === 'char-select-modal') {
            document.getElementById('char-select-modal').style.display = 'none';
        }
    }

    function selectDeckChar(charId) {
        socket.emit('update_deck_slot', { roomId: currentRoom, slotIndex: currentSlotIndex, charId: charId });
        document.getElementById('char-select-modal').style.display = 'none';
    }

    function finishMatch() {
        if (confirm("Are you sure you want to save and finish?")) {
            socket.emit('finish_match_setup', { roomId: currentRoom });
        }
    }

    // --- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ИЗ СТАРОГО КОДА ---
    function updateImmunityTop(state) {
         const topDisp = document.getElementById('immunity-top-display');
         if(state.draftType !== 'gitcg_cup_2') { topDisp.style.display = 'none'; return; }
         topDisp.style.display = 'flex';
         const row = document.getElementById('immunity-icons-row'); row.innerHTML = '';
         const bans = state.immunityBans || []; const picks = state.immunityPool || [];
         const slots = [ { val: bans[0], type: 'ban' }, { val: picks[0], type: 'pick' }, { val: picks[1], type: 'pick' }, { val: bans[1], type: 'ban' } ];
         slots.forEach(slot => {
             const div = document.createElement('div'); div.className = `im-icon im-${slot.type}`;
             if (slot.val === 'skipped') { div.innerHTML = `<span style="color:#aaa; font-size:20px; line-height:36px; display:block; text-align:center;">✖</span>`; div.style.background = '#222'; } 
             else if (slot.val) {
                 let all = []; Object.values(charsData).forEach(a => all.push(...a));
                 const char = all.find(c => c.id === slot.val);
                 if(char) div.innerHTML = `<img src="${char.img}">`;
             } else div.classList.add('im-empty');
             row.appendChild(div);
         });
    }

    function getStepsFor(schema, team, type) {
         if (!schema) return [];
         return schema.map((step, index) => ({ ...step, globalIndex: index + 1 })).filter(step => step.team === team && step.type === type).map(step => ({ num: step.globalIndex, immunity: step.immunity }));
    }

    function renderSlots(state) {
         const currentSchema = DRAFT_RULES[currentDraftType];
         if (!currentSchema) return;
         const blueBanSteps = getStepsFor(currentSchema, 'blue', 'ban'); const redBanSteps = getStepsFor(currentSchema, 'red', 'ban');
         const bluePickSteps = getStepsFor(currentSchema, 'blue', 'pick'); const redPickSteps = getStepsFor(currentSchema, 'red', 'pick');
         const fill = (containerId, items, stepData, isBan) => {
             const div = document.getElementById(containerId); if(!div) return; div.innerHTML = ''; 
             stepData.forEach((step, i) => {
                 const slot = document.createElement('div'); slot.className = 'slot-circle';
                 if (isBan) slot.classList.add('slot-ban');
                 if (step.immunity) slot.classList.add('slot-immunity-pick');
                 if (!state.immunityPhaseActive && state.gameStarted && !savedData && step.num === state.stepIndex) slot.classList.add('active-slot');
                 let charId = null; if (items[i]) charId = typeof items[i] === 'object' ? items[i].id : items[i];
                 if (charId) {
                     let allFlat = []; Object.values(charsData).forEach(arr => allFlat.push(...arr));
                     const char = allFlat.find(c => c.id === charId);
                     if (char) slot.innerHTML = `<img src="${char.img}">`;
                 } else slot.innerHTML = `<span class="step-number">${step.num}</span>`;
                 div.appendChild(slot);
             });
         };
         fill('blue-bans', state.bans.filter(b => b.team === 'blue'), blueBanSteps, true);
         fill('red-bans', state.bans.filter(b => b.team === 'red'), redBanSteps, true);
         if (currentDraftType === 'generals_2' || currentDraftType === 'classic') {
             fill('blue-picks-1', state.bluePicks, bluePickSteps, false); fill('blue-picks-2', [], [], false); 
             fill('red-picks-1', state.redPicks, redPickSteps, false); fill('red-picks-2', [], [], false);
         } else {
             fill('blue-picks-1', state.bluePicks.slice(0, 5), bluePickSteps.slice(0, 5), false);
             fill('blue-picks-2', state.bluePicks.slice(5, 9), bluePickSteps.slice(5, 9), false);
             fill('red-picks-1', state.redPicks.slice(0, 5), redPickSteps.slice(0, 5), false);
             fill('red-picks-2', state.redPicks.slice(5, 9), redPickSteps.slice(5, 9), false);
         }
    }
</script>

<%- include('../partials/footer') %>
